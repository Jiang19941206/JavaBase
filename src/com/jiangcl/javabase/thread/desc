程序：为完成特定任务，用某种语言编写的一组指令集合。即一段静态的代码，静态对象
进程：进程是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：有它自己的产生，存在和消亡的过程
线程：进程可细分为线程，是一个程序内部的执行路径。线程作为调度和执行单位，每个线程拥有独立的运行栈和程序计数器

线程常用方法：
setName()：设置当前线程名称。
yield()：释放cpu对当前线程的执行权。
join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b执行完过后，线程a才结束阻塞状态。
sleep(long time)：将线程阻塞指定时间。
isAlive()：判断线程时候存活
setPriority(Thread.MAX_PRIORITY)：MAX_PRIORITY最高优先级，MIN_PRIORITY最低优先级，NORM_PRIORITY正常优先级
                                  高优先级的线程要抢用低优先级线程的CPU执行权，
                                  此参数只是提高高优先级线程的执行概率，
                                  但是并不意味着是当高优先级线程执行完过后在执行低优先级线程。

继承Thread和实现Runnable创建多线程方式的对比（优先选择实现Runnable方式）
    从单继承和多实现方面进行对比，一个类只能继承一个父类，但可以实现多个接口。
    实现接口的方式更适合处理多个线程有共享数据的情况


线程的生命周期
        新建：线程创建
        就绪：执行start()后，等待分配CPU资源
        运行：就绪状态线程被调度，并获得CPU资源
        阻塞：临时中断线程的执行
        死亡：线程完成它的全部过后或者被强制终止或者出现异常导致结束


线程安全问题
        问题描述：当多个线程要操作共享数据时会存在线程安全问题
        解决方法：使用同步方法、同步代码块(synchronized)、Lock锁

        同步监视器（同步锁）：任何一个类的对象都可充当锁
                                要求：多个线程必须要共用同一把锁

        synchronized和Lock锁的异同
                    相同：二者都可以解决线程安全问题
                    不同：synchronized在执行完同步代码后会自动释放同步，Lock锁启动同步与释放同步都需要手动操作
        解决线程安全问题方式选择优先顺序：Lock锁（较为灵活） > 同步代码块 > 同步方法

线程死锁
        问题描述：不同的线程分别占用对方需要的同步资源不放弃，
                  都在等待对方放弃自己需要的同步资源，就形成了死锁
                  在出现死锁后，程序不会报错，不会提示，只是所有的线程都处于阻塞，状态无法继续
        如何避免：专门的算法、原则
                  尽量减少同步资源的定义
                  尽量避免嵌套同步

