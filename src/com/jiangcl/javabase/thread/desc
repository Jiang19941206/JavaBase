程序：为完成特定任务，用某种语言编写的一组指令集合。即一段静态的代码，静态对象
进程：进程是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：有它自己的产生，存在和消亡的过程
线程：进程可细分为线程，是一个程序内部的执行路径。线程作为调度和执行单位，每个线程拥有独立的运行栈和程序计数器

线程常用方法：
setName()：设置当前线程名称。
yield()：释放cpu对当前线程的执行权。
join()：在线程a中调用线程b的join()，此时线程a进入阻塞状态，直到线程b执行完过后，线程a才结束阻塞状态。
sleep(long time)：将线程阻塞指定时间。
isAlive()：判断线程时候存活
setPriority(Thread.MAX_PRIORITY)：MAX_PRIORITY最高优先级，MIN_PRIORITY最低优先级，NORM_PRIORITY正常优先级
                                  高优先级的线程要抢用低优先级线程的CPU执行权，
                                  此参数只是提高高优先级线程的执行概率，
                                  但是并不意味着是当高优先级线程执行完过后在执行低优先级线程。

继承Thread和实现Runnable创建多线程方式的对比（优先选择实现Runnable方式）
    从单继承和多实现方面进行对比，一个类只能继承一个父类，但可以实现多个接口。
    实现接口的方式更适合处理多个线程有共享数据的情况


线程的生命周期
        新建：线程创建
        就绪：执行start()后，等待分配CPU资源
        运行：就绪状态线程被调度，并获得CPU资源
        阻塞：临时中断线程的执行
        死亡：线程完成它的全部过后或者被强制终止或者出现异常导致结束


线程安全问题
        问题描述：当多个线程要操作共享数据时会存在线程安全问题
        解决方法：使用同步方法、同步代码块(synchronized)、Lock锁

        同步监视器（同步锁）：任何一个类的对象都可充当锁
                                要求：多个线程必须要共用同一把锁

        synchronized和Lock锁的异同
                    相同：二者都可以解决线程安全问题
                    不同：synchronized在执行完同步代码后会自动释放同步，Lock锁启动同步与释放同步都需要手动操作
        解决线程安全问题方式选择优先顺序：Lock锁（较为灵活） > 同步代码块 > 同步方法

线程死锁
        问题描述：不同的线程分别占用对方需要的同步资源不放弃，
                  都在等待对方放弃自己需要的同步资源，就形成了死锁
                  在出现死锁后，程序不会报错，不会提示，只是所有的线程都处于阻塞，状态无法继续
        如何避免：专门的算法、原则
                  尽量减少同步资源的定义
                  尽量避免嵌套同步


线程的通信
        涉及到的三个方法
                  wait()：当执行此方法后，线程会进入阻塞状态，并释放同步锁。
                  notify()：当执行此方法后，会唤醒被wait的一个线程，如果有多个线程处于wait状态，则唤醒优先级高的那一个
                  notifyAll()：当执行此方法后，会唤醒所有被wait的线程
              注意：此三种方法只能在同步代码块或者同步方法中（使用Lock时不能使用此三种方法）。
                    三个方法的调用者必须是同步方法或同步代码块的同步锁。

        sleep()和wait()的异同
                相同点：执行这两个方法都可以使当前线程进入阻塞状态
                不同点：1、两个方法声明的位置不同，sleep是Thread类中的，wait是Obj中的。
                        2、sleep可以在任何需要的场景下调用，wait只能用在同步方法或者同步代码块中。
                        3、如果两个方法都在同步方法或者同步代码块中，sleep不会释放同步锁，wait会释放同步锁。


线程池
    创建一个指定数量的线程池
    ExecutorService service = Executors.newFixedThreadPool(10);
            service.submit()适用于实现Callable接口的线程
            service.execute()适用于实现Runnable接口的线程


总结：
      创建线程的四种方式
            继承Thread类，实现Runnable接口，实现Callable接口，使用线程池